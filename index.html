<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Snakes & Ladders â€” Modern (Mobile Friendly)</title>
<link rel="manifest" href="./manifest.json">
<link rel="icon" type="image/jpeg" href="./favicon1.jpeg">
<style>
  :root{
    --bg1:#071026; --bg2:#081329;
    --glass: rgba(255,255,255,0.04);
    --muted: rgba(255,255,255,0.7);
    --max-board: 720px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto,Arial;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#e8f0ff;overflow:hidden;-webkit-tap-highlight-color:transparent}
  /* Outer wrapper that can be rotated for landscape or orientation tilt */
  .game-wrapper{width:100vw;height:100vh;display:flex;align-items:center;justify-content:center;transform-origin:center center;transition:transform .45s ease}
  /* When 'force landscape' is active, add class .rotated90 to rotate 90deg */
  .rotated90{transform:rotate(90deg) translateY(-100%);width:100vh;height:100vw}
  /* Main layout */
  .wrap{width:min(1180px,94vmin);max-width:100%;display:grid;grid-template-columns:1fr 360px;gap:14px;align-items:start;padding:14px}
  @media (max-width:900px){ .wrap{grid-template-columns:1fr;gap:12px;padding:10px} }
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  .title{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
  .title h1{font-size:18px;margin:0}
  .subtitle{font-size:12px;color:var(--muted)}
  /* Board container: uses vmin so it scales on phones without cropping */
  .board-wrap{position:relative;display:flex;justify-content:center;align-items:center}
  .board {
    width: min(var(--max-board), 82vmin);
    height: min(var(--max-board), 82vmin);
    max-width:100%;
    max-height:100%;
    border-radius:10px;
    overflow:visible;
    position:relative;
    border:5px solid rgba(255,255,255,0.04);
    background:linear-gradient(180deg, rgba(2,6,23,0.6), rgba(2,6,23,0.45));
    display:block;
  }
  /* ensure board image always fully visible (no cropping) */
  .board img{display:block;width:100%;height:100%;object-fit:contain;background:#061025}
  /* overlay grid */
  .grid{position:absolute;inset:0;display:grid;grid-template-columns:repeat(10,1fr);grid-template-rows:repeat(10,1fr);pointer-events:none}
  .cell .idx{display:none}
  /* tokens */
  .token{position:absolute;width:44px;height:44px;border-radius:50%;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:900;box-shadow:0 10px 20px rgba(2,6,23,0.6);border:3px solid rgba(255,255,255,0.9);transform:translate(-50%,-50%);transition:left 420ms cubic-bezier(.2,.9,.3,1),top 420ms,transform 320ms}
  .token.blue{background:linear-gradient(180deg,#3b82f6,#2563eb)}
  .token.red{background:linear-gradient(180deg,#fb7185,#ef4444)}
  /* Controls column */
  .controls{display:flex;flex-direction:column;gap:12px}
  .mode-buttons{display:flex;gap:8px;flex-wrap:wrap}
  .btn, .btn-ghost{padding:8px 10px;border-radius:10px;border:none;cursor:pointer;font-weight:800}
  .btn{background:linear-gradient(90deg,#0ea5e9,#7c3aed);color:white}
  .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit}
  .dice{width:110px;height:110px;border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:26px;font-weight:900;color:white;cursor:pointer;user-select:none;border:3px solid rgba(255,255,255,0.05);box-shadow:0 12px 40px rgba(2,6,23,0.6);transition:transform .9s cubic-bezier(.22,.9,.3,1)}
  .dice.rolling{transform:rotate(720deg) scale(1.02)}
  .pill{padding:8px 10px;border-radius:999px;background:rgba(255,255,255,0.03);font-weight:700}
  .log{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;max-height:200px;overflow:auto;font-size:13px}
  .donate{background:linear-gradient(90deg,#fff7ed,#fff1e6);color:#1f2937;padding:12px;border-radius:10px}
  .donate .till{font-weight:900;font-size:18px}
  .muted{font-size:12px;color:var(--muted)}
  .winner-banner{position:absolute;left:50%;top:8px;transform:translateX(-50%);padding:8px 14px;border-radius:999px;background:linear-gradient(90deg,#fef3c7,#fde68a);color:#111;font-weight:900;display:none;z-index:60}
  .highlight-burst{position:absolute;pointer-events:none;border-radius:999px;box-shadow:0 6px 28px rgba(255,255,255,0.12);opacity:0;transform:scale(0.85);transition:opacity 260ms, transform 260ms}
  /* enable tilt transform by setting CSS var --tilt */
  .board-tilt{transition: transform 200ms ease; transform-origin:50% 50%;}
  /* responsive adjustments */
  @media (max-width:720px){
    .dice{width:92px;height:92px;font-size:22px}
    .token{width:40px;height:40px}
  }
  /* small helper for hidden text-selection and touch ease */
  button, .btn{ -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
</style>
</head>
<body>
<div id="gameWrapper" class="game-wrapper">
  <div class="wrap">
    <!-- Board area -->
    <div class="card board-wrap">
      <div class="title">
        <div>
          <h1>Snakes & Ladders</h1>
          <div class="subtitle">Blue vs Red â€” First to 100 wins</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="resetBtn" class="btn-ghost">Reset</button>
          <div id="movesCount" class="muted">Moves: 0</div>
        </div>
      </div>

      <div id="boardContainer" class="board board-tilt" role="application" aria-label="Snakes and Ladders board">
        <img id="boardImg" src="./snakes.jpg" alt="Snakes and Ladders board" crossorigin="anonymous" />
        <div id="grid" class="grid" aria-hidden="true"></div>

        <!-- tokens -->
        <div id="token-blue" class="token blue" style="left:8%;top:86%;z-index:40"><div class="label">B</div></div>
        <div id="token-red" class="token red" style="left:14%;top:86%;z-index:41"><div class="label">R</div></div>

        <div id="winnerBanner" class="winner-banner">Winner!</div>
        <div id="burst" class="highlight-burst" style="width:120px;height:120px;left:50%;top:50%;transform:translate(-50%,-50%)"></div>
      </div>
    </div>

    <!-- Controls column -->
    <aside class="card controls">
      <div style="display:flex;align-items:center;justify-content:space-between">
        <div>
          <div style="font-weight:900;font-size:16px">Controls</div>
          <div class="muted">Tap dice to roll. Use two-player or play vs computer.</div>
        </div>
        <div class="pill">Turn: <span id="turnName">Blue</span></div>
      </div>

      <div style="display:flex;gap:12px;align-items:center;margin-top:8px">
        <div id="dice" class="dice" title="Click to roll">
          <div style="text-align:center">
            <div style="font-size:12px;opacity:0.95">Roll</div>
            <div id="diceVal" style="font-size:22px">â€”</div>
          </div>
        </div>

        <div style="flex:1;display:flex;flex-direction:column;gap:8px">
          <div style="display:flex;justify-content:space-between;gap:10px">
            <div class="mode-buttons" aria-hidden="false">
              <button id="modeTwo" class="btn-ghost">Two Players</button>
              <button id="modeAI" class="btn">Play vs Computer</button>
            </div>
            <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
              <div class="muted">Tilt: <button id="enableTilt" class="btn-ghost">Enable Tilt</button></div>
              <div class="muted" style="font-size:11px">Orientation: <button id="askRotate" class="btn-ghost">Allow Rotate</button></div>
            </div>
          </div>

          <div style="display:flex;gap:8px">
            <div class="pill" id="blueStat">Blue: 0</div>
            <div class="pill" id="redStat">Red: 0</div>
          </div>

          <div class="log" id="log">No moves yet</div>
        </div>
      </div>

      <div style="margin-top:8px">
        <div class="donate">
          <div style="font-weight:800">Support Us (M-Pesa)</div>
          <div style="margin-top:8px; display:flex;align-items:center;justify-content:space-between">
            <div>
              <div style="font-size:13px">Till number</div>
              <div class="till">4713786</div>
            </div>
            <div><button id="copyBtn" class="copy">Copy</button></div>
          </div>
          <div style="margin-top:8px;font-size:12px;color:#111">Use Lipa na M-Pesa â†’ Pay Bill/Till â†’ enter till number and amount.</div>
        </div>
      </div>

      <div style="margin-top:10px">
        <div style="font-weight:800">Rules</div>
        <ul style="font-size:13px;margin:8px 0 0 18px">
          <li>Roll 1â€“6, move forward square-by-square.</li>
          <li>Land on ladder base â†’ climb up.</li>
          <li>Land on snake head â†’ slide down.</li>
        </ul>
      </div>
    </aside>
  </div>
</div>

<!-- Game script -->
<script>
/* ============================
   Game config & helpers
   ============================ */
const BOARD_SIZE = 10;
const gridEl = document.getElementById('grid');
const cells = []; // index 1..100 => grid cell element

// Create invisible grid cells (numbers hidden via CSS)
for(let r=0;r<BOARD_SIZE;r++){
  for(let c=0;c<BOARD_SIZE;c++){
    const div = document.createElement('div');
    div.className = 'cell';
    const idx = document.createElement('div');
    idx.className = 'idx';
    const number = calcCellNumber(r,c);
    idx.textContent = number;
    div.appendChild(idx);
    div.dataset.num = number;
    gridEl.appendChild(div);
    cells[number] = div;
  }
}

function calcCellNumber(row,col){
  const rFromBottom = (BOARD_SIZE - 1) - row;
  const base = rFromBottom * BOARD_SIZE;
  if(rFromBottom % 2 === 0) return base + col + 1;
  return base + (BOARD_SIZE - col);
}

const board = document.getElementById('boardContainer');
function getCellCenter(num){
  const rect = board.getBoundingClientRect();
  if(!cells[num]) return { x: rect.width * 0.08, y: rect.height * 0.92 };
  const crect = cells[num].getBoundingClientRect();
  return {
    x: crect.left - rect.left + crect.width/2,
    y: crect.top - rect.top + crect.height/2
  };
}

/* exact user-requested mappings */
const LADDERS = { 3:45, 8:12, 14:26, 21:39, 31:73, 59:80, 90:92, 83:97 };
const SNAKES = { 99:41, 95:67, 89:85, 57:2, 54:27, 11:6 };

/* game state */
let positions = [0,0]; // 0 = Blue, 1 = Red or Computer
let currentPlayer = 0;
let moves = 0;
let gameMode = 'ai'; // 'ai' or 'two'
let rolling = false;
let tiltEnabled = false;

/* elements */
const tokenBlue = document.getElementById('token-blue');
const tokenRed = document.getElementById('token-red');
const dice = document.getElementById('dice');
const diceVal = document.getElementById('diceVal');
const turnName = document.getElementById('turnName');
const blueStat = document.getElementById('blueStat');
const redStat = document.getElementById('redStat');
const logEl = document.getElementById('log');
const movesCountEl = document.getElementById('movesCount');
const winnerBanner = document.getElementById('winnerBanner');
const burst = document.getElementById('burst');
const resetBtn = document.getElementById('resetBtn');
const modeTwoBtn = document.getElementById('modeTwo');
const modeAIBtn = document.getElementById('modeAI');
const copyBtn = document.getElementById('copyBtn');
const enableTiltBtn = document.getElementById('enableTilt');
const askRotateBtn = document.getElementById('askRotate');
const wrapper = document.getElementById('gameWrapper');

/* Initialization */
setDiceColor();
updateStats();
placeToken('blue',0);
placeToken('red',0);
highlightModeButton();

/* ---------------------------
   Token placement & movement
   --------------------------- */
function placeToken(which,num){
  const el = which === 'blue' ? tokenBlue : tokenRed;
  const { x, y } = num > 0 ? getCellCenter(num) : { x: board.clientWidth * (which === 'blue' ? 0.08 : 0.14), y: board.clientHeight * 0.92 };
  el.style.left = x + 'px';
  el.style.top = y + 'px';
}

window.addEventListener('resize', ()=>{ placeToken('blue', positions[0]); placeToken('red', positions[1]); });

async function animatePath(playerIndex, pathNums){
  const el = playerIndex === 0 ? tokenBlue : tokenRed;
  for(const n of pathNums){
    const { x, y } = n > 0 ? getCellCenter(n) : { x: board.clientWidth * (playerIndex === 0 ? 0.08 : 0.14), y: board.clientHeight * 0.92 };
    el.style.transform = 'translate(-50%,-60%) scale(1.03)';
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    await sleep(260);
    el.style.transform = 'translate(-50%,-50%) scale(1)';
    await sleep(120);
  }
}

async function animateJump(playerIndex, fromNum, toNum, type){
  const el = playerIndex === 0 ? tokenBlue : tokenRed;
  const start = getCellCenter(fromNum);
  const end = getCellCenter(toNum);
  showBurst((start.x + end.x)/2, (start.y + end.y)/2);
  el.style.transition = 'transform 420ms, left 420ms, top 420ms';
  el.style.transform = 'translate(-50%,-70%) scale(1.06)';
  el.style.left = end.x + 'px';
  el.style.top = end.y + 'px';
  await sleep(520);
  el.style.transform = 'translate(-50%,-50%) scale(1)';
  await sleep(120);
}

/* ---------------------------
   Dice & player flow
   --------------------------- */
dice.addEventListener('click', async ()=>{
  if(rolling) return;
  if(gameMode === 'ai' && currentPlayer === 1) return; // block if it's computer's turn
  if(positions[0] === 100 || positions[1] === 100) { alert('Game over. Reset to play again.'); return; }
  rolling = true; dice.classList.add('rolling'); setDiceColor(true);
  const result = Math.floor(Math.random() * 6) + 1;
  diceVal.textContent = '...';
  await sleep(620);
  diceVal.textContent = result;
  dice.classList.remove('rolling'); rolling = false;
  moves++; movesCountEl.textContent = 'Moves: ' + moves;
  await handleMove(result);
});

async function handleMove(roll){
  const p = currentPlayer;
  const start = positions[p];
  let target = start + roll;
  if(target > 100){
    addLog(`${playerName(p)} rolled ${roll} â€” can't pass 100 (stays ${start})`);
    switchTurn();
    return;
  }
  addLog(`${playerName(p)} rolled ${roll} â€” moving to ${target}`);
  const path = [];
  for(let s = start + 1; s <= target; s++) path.push(s);
  await animatePath(p, path);
  positions[p] = target; updateStats();

  // ladder or snake
  if(LADDERS[target]){
    const dest = LADDERS[target];
    addLog(`${playerName(p)} landed on a ladder! climbing to ${dest}`);
    await animateJump(p, target, dest, 'ladder');
    positions[p] = dest; updateStats();
    if(SNAKES[dest]){ const down = SNAKES[dest]; addLog(`${playerName(p)} hit a snake at ${dest} -> ${down}`); await animateJump(p, dest, down, 'snake'); positions[p] = down; updateStats(); }
  } else if(SNAKES[target]){
    const dest = SNAKES[target];
    addLog(`${playerName(p)} landed on a snake! sliding to ${dest}`);
    await animateJump(p, target, dest, 'snake');
    positions[p] = dest; updateStats();
  }

  if(positions[p] === 100){ declareWinner(p); return; }

  switchTurn();

  // if vs computer and now it's computer's turn, let it play
  if(gameMode === 'ai' && currentPlayer === 1){
    // small pause then auto-roll
    await sleep(700 + Math.random()*600);
    await computerPlay();
  }
}

function switchTurn(){
  currentPlayer = 1 - currentPlayer;
  turnName.textContent = currentPlayer === 0 ? 'Blue' : (gameMode === 'ai' ? 'Computer' : 'Red');
  setDiceColor();
}

function setDiceColor(instantly){
  dice.style.background = currentPlayer === 0 ? 'linear-gradient(180deg,#3b82f6,#2563eb)' : 'linear-gradient(180deg,#fb7185,#ef4444)';
  if(instantly){ dice.style.transition = 'none'; setTimeout(()=>dice.style.transition = '', 120); }
}

function updateStats(){
  blueStat.textContent = `Blue: ${positions[0]}`;
  redStat.textContent = gameMode === 'ai' ? `Computer: ${positions[1]}` : `Red: ${positions[1]}`;
  placeToken('blue', positions[0]);
  placeToken('red', positions[1]);
}

/* ---------------------------
   Utility & logging
   --------------------------- */
function playerName(i){ return i === 0 ? 'Blue' : (gameMode === 'ai' ? 'Computer' : 'Red'); }
function addLog(msg){
  const d = document.createElement('div'); d.innerHTML = `${new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})} â€¢ ${msg}`;
  logEl.prepend(d);
  while(logEl.children.length > 10) logEl.removeChild(logEl.lastChild);
}
function declareWinner(playerIndex){
  addLog(`${playerName(playerIndex)} reached 100 â€” wins!`);
  winnerBanner.style.display = 'block';
  winnerBanner.textContent = `${playerName(playerIndex)} wins! ðŸŽ‰`;
  confettiBurst();
}

/* ---------------------------
   Simple AI (computer) player
   --------------------------- */
async function computerPlay(){
  // very basic strategy: just roll
  if(positions[0] === 100 || positions[1] === 100) return;
  // prevent user click during computer play
  rolling = true;
  dice.classList.add('rolling');
  setDiceColor(true);
  const result = Math.floor(Math.random() * 6) + 1;
  diceVal.textContent = '...';
  await sleep(700);
  diceVal.textContent = result;
  dice.classList.remove('rolling');
  rolling = false;
  moves++; movesCountEl.textContent = 'Moves: ' + moves;
  await handleMove(result);
}

/* ---------------------------
   Confetti
   --------------------------- */
function confettiBurst(){
  const w = board.clientWidth, h = board.clientHeight;
  const canvas = document.createElement('canvas');
  canvas.width = w; canvas.height = h;
  canvas.style.position = 'absolute'; canvas.style.left = 0; canvas.style.top = 0; canvas.style.zIndex = 80;
  board.appendChild(canvas);
  const ctx = canvas.getContext('2d');
  const pieces = [];
  for(let i=0;i<60;i++){
    pieces.push({
      x: Math.random() * w,
      y: Math.random() * -h,
      vx: (Math.random() - 0.5) * 6,
      vy: 2 + Math.random() * 6,
      size: 6 + Math.random() * 8,
      color: ['#f97316','#60a5fa','#f472b6','#34d399','#fef08a'][Math.floor(Math.random()*5)],
      rot: Math.random()*Math.PI
    });
  }
  let t = 0;
  function frame(){
    t++;
    ctx.clearRect(0,0,w,h);
    for(const p of pieces){
      p.x += p.vx; p.y += p.vy; p.rot += 0.1;
      ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot);
      ctx.fillStyle = p.color; ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
      ctx.restore();
    }
    if(t < 140) requestAnimationFrame(frame);
    else canvas.remove();
  }
  frame();
}

/* ---------------------------
   Buttons & UI interactions
   --------------------------- */
modeTwoBtn.addEventListener('click', ()=>{
  if(gameMode !== 'two'){
    gameMode = 'two';
    resetGame();
    highlightModeButton();
  }
});
modeAIBtn.addEventListener('click', ()=>{
  if(gameMode !== 'ai'){
    gameMode = 'ai';
    resetGame();
    highlightModeButton();
  }
});
function highlightModeButton(){
  if(gameMode === 'ai'){ modeAIBtn.style.opacity = '1'; modeTwoBtn.style.opacity = '0.7'; }
  else { modeTwoBtn.style.opacity = '1'; modeAIBtn.style.opacity = '0.7'; }
}

copyBtn.addEventListener('click', async ()=>{
  try { await navigator.clipboard.writeText('4713786'); copyBtn.textContent = 'Copied!'; setTimeout(()=>copyBtn.textContent='Copy',1200); }
  catch(e){ alert('Copy failed â€” please copy: 4713786'); }
});

resetBtn.addEventListener('click', ()=> resetGame());

function resetGame(){
  positions = [0,0];
  currentPlayer = 0;
  moves = 0;
  rolling = false;
  diceVal.textContent = 'â€”';
  turnName.textContent = 'Blue';
  winnerBanner.style.display = 'none';
  movesCountEl.textContent = 'Moves: 0';
  logEl.innerHTML = 'No moves yet';
  updateStats();
  setDiceColor();
}

/* ---------------------------
   Small helpers
   --------------------------- */
function sleep(ms){ return new Promise(res => setTimeout(res, ms)); }

/* ---------------------------
   Orient + Tilt functionality
   --------------------------- */
/* PART A: ask for fullscreen + lock to landscape (Screen Orientation API) */
async function requestLandscapeMode(){
  if(screen.orientation && screen.orientation.lock){
    try{
      const allow = confirm("Rotate to landscape for a better experience?");
      if(!allow) return;
      // enter fullscreen; required on many browsers
      if(document.documentElement.requestFullscreen) await document.documentElement.requestFullscreen();
      await screen.orientation.lock('landscape');
      // add rotated class to wrapper for times when device doesn't actually rotate display
      wrapper.classList.add('rotated90');
    }catch(err){
      console.warn('Orientation lock failed:', err);
    }
  } else {
    // fallback: visually rotate wrapper
    wrapper.classList.add('rotated90');
  }
}
askRotateBtn.addEventListener('click', requestLandscapeMode);

/* PART B: Device tilt - subtle rotation of the board based on device orientation */
let lastTilt = 0;
function handleDeviceOrientation(e){
  if(!tiltEnabled) return;
  // gamma ~ left-right tilt (-90..90). Use small mapping to degrees.
  const gamma = e.gamma || 0; // left-right tilt
  // clamp to [-35, 35] then map to smaller tilt degrees
  const clamped = Math.max(-35, Math.min(35, gamma));
  const deg = (clamped / 35) * 12; // up to Â±12deg visual tilt
  // apply transform to board (not wrapper) for subtle effect
  const boardEl = document.getElementById('boardContainer');
  boardEl.style.transform = `rotate(${wrapper.classList.contains('rotated90') ? 90 : 0}deg) rotateZ(${deg}deg)`;
  lastTilt = deg;
}

async function enableTilt(){
  // iOS 13+ requires DeviceOrientationEvent.requestPermission invoked by user gesture
  if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
    try{
      const resp = await DeviceOrientationEvent.requestPermission();
      if(resp === 'granted'){
        tiltEnabled = true;
        window.addEventListener('deviceorientation', handleDeviceOrientation, true);
        enableTiltBtn.textContent = 'Tilt: ON';
        enableTiltBtn.disabled = true;
      } else {
        alert('Tilt permission denied.');
      }
    } catch(err){
      console.warn('Tilt permission error', err); alert('Tilt not available.');
    }
  } else {
    // other browsers usually allow deviceorientation by default
    tiltEnabled = true;
    window.addEventListener('deviceorientation', handleDeviceOrientation, true);
    enableTiltBtn.textContent = 'Tilt: ON';
    enableTiltBtn.disabled = true;
  }
}
enableTiltBtn.addEventListener('click', enableTilt);

/* Also handle removing tilt transforms when not enabled or on resize */
window.addEventListener('resize', ()=>{
  const boardEl = document.getElementById('boardContainer');
  if(!tiltEnabled) boardEl.style.transform = wrapper.classList.contains('rotated90') ? 'rotate(90deg)' : 'none';
  placeToken('blue', positions[0]); placeToken('red', positions[1]);
});

/* Keep rotation class synced with screen orientation changes */
function handleOrientationChange(){
  // visually add rotated90 if portrait (to force landscape look) OR rely on manifest/fullscreen
  // we don't automatically force rotate here; we only ensure a consistent transform if fullscreen orientation locked
  if(screen.orientation && screen.orientation.type && screen.orientation.type.includes('landscape')){
    wrapper.classList.remove('rotated90');
    document.getElementById('boardContainer').style.transform = 'none';
  }
}
window.addEventListener('orientationchange', handleOrientationChange);

/* ---------------------------
   Ensure tokens placed AFTER image load
   --------------------------- */
const boardImg = document.getElementById('boardImg');
if(boardImg.complete) updateStats();
else boardImg.addEventListener('load', updateStats);

/* ---------------------------
   Accessibility: small focus outlines
   --------------------------- */
document.querySelectorAll('button').forEach(btn=>{
  btn.addEventListener('focus', ()=> btn.style.outline = '2px solid rgba(255,255,255,0.12)');
  btn.addEventListener('blur', ()=> btn.style.outline = 'none');
});
</script>

<!-- Ctrl+U prevention script as requested -->
<script>
  document.addEventListener("keydown", function(e) {
    if (e.ctrlKey && (e.key === "u" || e.key === "U")) {
      e.preventDefault();
      alert("You are not allowed to copy content or view source!");
    }
  });
</script>
</body>
</html>
