<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snakes & Ladders â€” Modern (Custom)</title>
<style>
  :root{
    --bg1: #071026;
    --bg2: #081329;
    --glass: rgba(255,255,255,0.04);
    --muted: rgba(255,255,255,0.7);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#e8f0ff}
  .wrap{max-width:1180px;margin:28px auto;padding:18px;display:grid;grid-template-columns:1fr 380px;gap:18px;align-items:start}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:12px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  .title{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
  .title h1{font-size:20px;margin:0}
  .subtitle{font-size:13px;color:var(--muted)}
  /* Board */
  .board-wrap{position:relative;padding:10px}
  .board{width:720px;height:720px;max-width:100%;border-radius:12px;overflow:hidden;position:relative;border:6px solid rgba(255,255,255,0.04);background:#000;box-shadow:0 18px 40px rgba(2,6,23,0.6)}
  .board img{display:block;width:100%;height:100%;object-fit:cover;filter:contrast(1.02) saturate(1.05)}
  /* Grid overlay (invisible numbers) */
  .grid{position:absolute;inset:0;display:grid;grid-template-columns:repeat(10,1fr);grid-template-rows:repeat(10,1fr);pointer-events:none}
  .cell{position:relative;border:0}
  .cell .idx{display:none} /* hide numbers overlay as requested */
  /* Tokens */
  .token{position:absolute;width:48px;height:48px;border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-weight:900;box-shadow:0 10px 28px rgba(2,6,23,0.6);border:3px solid rgba(255,255,255,0.9);transform:translate(-50%,-50%);transition:left 420ms cubic-bezier(.2,.9,.3,1),top 420ms cubic-bezier(.2,.9,.3,1),transform 420ms}
  .token.blue{background:linear-gradient(180deg,#3b82f6,#2563eb)}
  .token.red{background:linear-gradient(180deg,#fb7185,#ef4444)}
  .token .label{font-size:13px;letter-spacing:0.5px}
  /* Dice & Controls */
  .controls{display:flex;flex-direction:column;gap:12px}
  .dice{width:120px;height:120px;border-radius:14px;display:flex;align-items:center;justify-content:center;font-size:28px;font-weight:900;color:white;cursor:pointer;user-select:none;border:4px solid rgba(255,255,255,0.05);box-shadow:0 14px 40px rgba(2,6,23,0.6);transition:transform .9s cubic-bezier(.22,.9,.3,1)}
  .dice.rolling{transform:rotate(720deg) scale(1.02)}
  .dice .small{font-size:13px;opacity:0.95}
  .meta{display:flex;gap:8px;align-items:center}
  .pill{padding:8px 10px;border-radius:999px;background:rgba(255,255,255,0.03);font-weight:700}
  .log{background:rgba(255,255,255,0.02);padding:10px;border-radius:10px;max-height:180px;overflow:auto;font-size:13px}
  .donate{background:linear-gradient(90deg,#fff7ed,#fff1e6);color:#1f2937;padding:12px;border-radius:10px}
  .donate .till{font-weight:900;font-size:20px}
  .copy{background:#f59e0b;padding:8px 12px;border-radius:10px;border:none;cursor:pointer;font-weight:800}
  .small-muted{font-size:12px;color:rgba(255,255,255,0.75)}
  .btn{padding:8px 10px;border-radius:10px;background:rgba(255,255,255,0.04);border:1px solid rgba(255,255,255,0.03);cursor:pointer}
  .winner-banner{position:absolute;left:50%;top:12px;transform:translateX(-50%);padding:10px 18px;border-radius:999px;background:linear-gradient(90deg,#fef3c7,#fde68a);color:#111;font-weight:900;display:none;z-index:60}
  /* small effects for ladders/snakes when triggered */ 
  .highlight-burst{position:absolute;pointer-events:none;border-radius:999px;box-shadow:0 6px 28px rgba(255,255,255,0.12);opacity:0;transform:scale(0.85);transition:opacity 260ms, transform 260ms}
  /* responsive */
  @media (max-width:1100px){.wrap{grid-template-columns:1fr;gap:14px}.board{height:min(90vw,720px)}}
</style>
</head>
<body>
<div class="wrap">
  <div class="card board-wrap">
    <div class="title">
      <div>
        <h1>Snakes & Ladders â€” Play</h1>
        <div class="subtitle">Blue vs Red â€” First to reach square 100 wins</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="resetBtn" class="btn">Reset</button>
        <div id="movesCount" class="small-muted">Moves: 0</div>
      </div>
    </div>

    <div class="board" id="board">
      <!-- Use your uploaded board file named 'snakes.jpg' next to this file -->
      <img src="./snakes.jpg" alt="Snakes & Ladders board" id="boardImg" crossorigin="anonymous" />
      <div id="grid" class="grid"></div>

      <div id="token-blue" class="token blue" style="left:48px;top:672px;z-index:50"><div class="label">B</div></div>
      <div id="token-red" class="token red" style="left:96px;top:672px;z-index:50"><div class="label">R</div></div>

      <div id="winnerBanner" class="winner-banner">Winner!</div>
      <!-- highlight visual -->
      <div id="burst" class="highlight-burst" style="width:120px;height:120px;left:50%;top:50%;transform:translate(-50%,-50%)"></div>
    </div>
  </div>

  <aside class="card controls">
    <div style="display:flex;align-items:center;justify-content:space-between">
      <div>
        <div style="font-weight:900;font-size:18px">Controls</div>
        <div class="small-muted">Click dice to roll. Dice color = current player.</div>
      </div>
      <div id="turnBadge" class="pill">Turn: <span id="turnName">Blue</span></div>
    </div>

    <div style="display:flex;gap:12px;align-items:center; margin-top:6px">
      <div id="dice" class="dice" title="Click to roll">
        <div style="text-align:center">
          <div class="small">Roll</div>
          <div id="diceVal" style="font-size:26px">â€”</div>
        </div>
      </div>

      <div style="flex:1;display:flex;flex-direction:column;gap:8px">
        <div class="meta">
          <div class="pill" id="blueStat">Blue: 0</div>
          <div class="pill" id="redStat">Red: 0</div>
        </div>
        <div class="log" id="log">No moves yet</div>
      </div>
    </div>

    <div style="margin-top:10px">
      <div class="donate">
        <div style="font-weight:800">Donate (M-Pesa)</div>
        <div style="margin-top:8px; display:flex;align-items:center;justify-content:space-between">
          <div>
            <div style="font-size:13px">Till number</div>
            <div class="till">4713786</div>
          </div>
          <div>
            <button id="copyBtn" class="copy">Copy</button>
          </div>
        </div>
        <div style="margin-top:8px;font-size:12px;color:#111">Use Lipa na M-Pesa â†’ Pay Bill/Till â†’ enter till number and amount.</div>
      </div>
    </div>

    <div style="margin-top:10px">
      <div style="font-weight:800">Rules & Notes</div>
      <ul style="font-size:13px;margin:8px 0 0 18px">
        <li>Roll 1â€“6, move forward square by square.</li>
        <li>If you land at bottom of ladder, you instantly climb to its top.</li>
        <li>If you land on a snake head, you slide down to its tail.</li>
        <li>Numbers printed on the board image are used; the overlay numbers are hidden.</li>
      </ul>
    </div>
  </aside>
</div>

<script>
  /***************
   * Board setup *
   ***************/
  const BOARD_SIZE = 10;
  const gridEl = document.getElementById('grid');
  const cells = []; // 1..100 -> element
  // create invisible grid cells
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      const div = document.createElement('div');
      div.className = 'cell';
      // hidden index for debugging but hidden by CSS
      const idx = document.createElement('div');
      idx.className = 'idx';
      const number = calcCellNumber(r, c);
      idx.textContent = number;
      div.appendChild(idx);
      div.dataset.num = number;
      gridEl.appendChild(div);
      cells[number] = div;
    }
  }

  function calcCellNumber(row, col) {
    // Zig-zag numbering bottom-left = 1
    const rFromBottom = (BOARD_SIZE - 1) - row;
    const base = rFromBottom * BOARD_SIZE;
    if (rFromBottom % 2 === 0) return base + col + 1;
    return base + (BOARD_SIZE - col);
  }

  // utility: get center coordinates of a cell relative to board container
  const board = document.getElementById('board');
  function getCellCenter(num) {
    const rect = board.getBoundingClientRect();
    if (!cells[num]) return { x: rect.width * 0.05, y: rect.height * 0.95 };
    const crect = cells[num].getBoundingClientRect();
    const x = crect.left - rect.left + crect.width / 2;
    const y = crect.top - rect.top + crect.height / 2;
    return { x, y };
  }

  // Reposition tokens when window resizes
  window.addEventListener('resize', () => {
    placeToken('blue', positions[0]);
    placeToken('red', positions[1]);
  });

  /**********************
   * Snake/Ladder maps  *
   * EXACT mappings user requested
   **********************/
  const LADDERS = {
    3: 45,
    8: 12,
    14: 26,
    21: 39,
    31: 73,
    59: 80,
    90: 92,
    83: 97
  };

  const SNAKES = {
    99: 41,
    95: 67,
    89: 85,
    57: 2,
    54: 27,
    11: 6
  };

  /**********************
   * Game state & elems *
   **********************/
  let positions = [0, 0]; // Blue = index 0, Red = index 1
  let currentPlayer = 0; // 0 = blue | 1 = red
  let moves = 0;
  const tokenBlue = document.getElementById('token-blue');
  const tokenRed = document.getElementById('token-red');
  const dice = document.getElementById('dice');
  const diceVal = document.getElementById('diceVal');
  const turnName = document.getElementById('turnName');
  const blueStat = document.getElementById('blueStat');
  const redStat = document.getElementById('redStat');
  const logEl = document.getElementById('log');
  const movesCountEl = document.getElementById('movesCount');
  const winnerBanner = document.getElementById('winnerBanner');
  const burst = document.getElementById('burst');
  const resetBtn = document.getElementById('resetBtn');

  // Initialize UI
  setDiceColor();
  updateStats();
  placeToken('blue', 0);
  placeToken('red', 0);

  /**********************
   * Movement & physics *
   **********************/
  function placeToken(which, num) {
    const el = which === 'blue' ? tokenBlue : tokenRed;
    const { x, y } = num > 0 ? getCellCenter(num) : { x: board.clientWidth * (which === 'blue' ? 0.08 : 0.14), y: board.clientHeight * 0.95 };
    el.style.left = x + 'px';
    el.style.top = y + 'px';
  }

  // animate path: step-by-step moves across squares
  async function animatePath(playerIndex, pathNums) {
    const el = playerIndex === 0 ? tokenBlue : tokenRed;
    for (let n of pathNums) {
      const { x, y } = n > 0 ? getCellCenter(n) : { x: board.clientWidth * (playerIndex === 0 ? 0.08 : 0.14), y: board.clientHeight * 0.95 };
      // small jump effect while moving
      el.style.transform = 'translate(-50%,-60%) scale(1.03)';
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      await sleep(300);
      el.style.transform = 'translate(-50%,-50%) scale(1)';
      await sleep(120);
    }
  }

  // animate ladder climb or snake slide (fancier arc)
  async function animateJump(playerIndex, fromNum, toNum, type) {
    const el = playerIndex === 0 ? tokenBlue : tokenRed;
    const start = getCellCenter(fromNum);
    const end = getCellCenter(toNum);
    // visual burst
    showBurst((start.x + end.x) / 2, (start.y + end.y) / 2);
    // scale & quick move
    el.style.transition = 'transform 420ms, left 420ms, top 420ms';
    el.style.transform = 'translate(-50%,-70%) scale(1.08)';
    el.style.left = end.x + 'px';
    el.style.top = end.y + 'px';
    await sleep(520);
    el.style.transform = 'translate(-50%,-50%) scale(1)';
    await sleep(120);
  }

  function showBurst(x, y) {
    burst.style.left = x + 'px';
    burst.style.top = y + 'px';
    burst.style.opacity = '1';
    burst.style.transform = 'translate(-50%,-50%) scale(1)';
    setTimeout(() => {
      burst.style.opacity = '0';
      burst.style.transform = 'translate(-50%,-50%) scale(0.85)';
    }, 480);
  }

  /**********************
   * Dice & player flow *
   **********************/
  let rolling = false;
  dice.addEventListener('click', async () => {
    if (rolling) return;
    if (positions[0] === 100 || positions[1] === 100) {
      alert('Game over. Reset to play again.');
      return;
    }
    rolling = true;
    dice.classList.add('rolling');
    // show dice color for current player
    setDiceColor(true);
    const result = Math.floor(Math.random() * 6) + 1;
    // show rolling animation time
    diceVal.textContent = '...';
    await sleep(720);
    diceVal.textContent = result;
    dice.classList.remove('rolling');
    rolling = false;
    moves++;
    movesCountEl.textContent = 'Moves: ' + moves;
    await handleMove(result);
  });

  async function handleMove(roll) {
    const p = currentPlayer;
    const start = positions[p];
    let target = start + roll;
    if (target > 100) {
      addLog(`${playerName(p)} rolled ${roll} â€” can't pass 100 (stays ${start})`);
      switchTurn();
      return;
    }
    addLog(`${playerName(p)} rolled ${roll} â€” moving to ${target}`);
    // animate square-by-square path
    const path = [];
    for (let s = start + 1; s <= target; s++) path.push(s);
    await animatePath(p, path);
    positions[p] = target;
    updateStats();

    // check ladders/snakes
    if (LADDERS[target]) {
      const dest = LADDERS[target];
      addLog(`${playerName(p)} landed on a ladder! climbing to ${dest}`);
      await animateJump(p, target, dest, 'ladder');
      positions[p] = dest;
      updateStats();
      // after ladder climb, check if chain (unlikely but safe)
      if (SNAKES[dest]) {
        const down = SNAKES[dest];
        addLog(`${playerName(p)} immediately hit a snake at ${dest} -> ${down}`);
        await animateJump(p, dest, down, 'snake');
        positions[p] = down;
        updateStats();
      }
    } else if (SNAKES[target]) {
      const dest = SNAKES[target];
      addLog(`${playerName(p)} landed on a snake! sliding to ${dest}`);
      await animateJump(p, target, dest, 'snake');
      positions[p] = dest;
      updateStats();
    }

    // check win
    if (positions[p] === 100) {
      declareWinner(p);
      return;
    }

    // switch turn
    switchTurn();
  }

  function switchTurn() {
    currentPlayer = 1 - currentPlayer;
    turnName.textContent = currentPlayer === 0 ? 'Blue' : 'Red';
    setDiceColor();
  }

  function setDiceColor(instantly) {
    if (currentPlayer === 0) {
      dice.style.background = 'linear-gradient(180deg,#3b82f6,#2563eb)';
    } else {
      dice.style.background = 'linear-gradient(180deg,#fb7185,#ef4444)';
    }
    if (instantly) {
      dice.style.transition = 'none';
      setTimeout(() => (dice.style.transition = ''), 100);
    }
  }

  function updateStats() {
    blueStat.textContent = `Blue: ${positions[0]}`;
    redStat.textContent = `Red: ${positions[1]}`;
    // reposition tokens visually
    placeToken('blue', positions[0]);
    placeToken('red', positions[1]);
  }

  function playerName(i) { return i === 0 ? 'Blue' : 'Red'; }
  function addLog(text) {
    const d = document.createElement('div');
    d.textContent = `${new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})} â€¢ ${text}`;
    logEl.prepend(d);
    // limit
    while (logEl.children.length > 8) logEl.removeChild(logEl.lastChild);
  }

  function declareWinner(playerIndex) {
    addLog(`${playerName(playerIndex)} reached 100 â€” wins!`);
    winnerBanner.style.display = 'block';
    winnerBanner.textContent = `${playerName(playerIndex)} wins! ðŸŽ‰`;
    // show confetti burst
    confettiBurst();
  }

  /**********************
   * Small utilities    *
   **********************/
  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

  // Copy button & reset
  document.getElementById('copyBtn').addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText('4713786');
      const btn = document.getElementById('copyBtn');
      btn.textContent = 'Copied!';
      setTimeout(() => (btn.textContent = 'Copy'), 1400);
    } catch (e) {
      alert('Copy failed â€” please copy manually: 4713786');
    }
  });

  resetBtn.addEventListener('click', () => {
    positions = [0, 0];
    currentPlayer = 0;
    moves = 0;
    diceVal.textContent = 'â€”';
    turnName.textContent = 'Blue';
    winnerBanner.style.display = 'none';
    movesCountEl.textContent = 'Moves: 0';
    logEl.innerHTML = 'No moves yet';
    updateStats();
    setDiceColor();
  });

  /**********************
   * Confetti (small)   *
   **********************/
  function confettiBurst() {
    // small inline confetti using canvas
    const w = board.clientWidth, h = board.clientHeight;
    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    canvas.style.position = 'absolute';
    canvas.style.left = 0; canvas.style.top = 0; canvas.style.zIndex = 80;
    board.appendChild(canvas);
    const ctx = canvas.getContext('2d');
    const pieces = [];
    for (let i = 0; i < 60; i++) {
      pieces.push({
        x: Math.random() * w,
        y: Math.random() * -h,
        vx: (Math.random() - 0.5) * 6,
        vy: 2 + Math.random() * 6,
        size: 6 + Math.random() * 8,
        color: ['#f97316','#60a5fa','#f472b6','#34d399','#fef08a'][Math.floor(Math.random()*5)],
        rot: Math.random()*Math.PI
      });
    }
    let t = 0;
    function drawFrame(){
      t++;
      ctx.clearRect(0,0,w,h);
      for (const p of pieces) {
        p.x += p.vx; p.y += p.vy; p.rot += 0.1;
        ctx.save();
        ctx.translate(p.x,p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
        ctx.restore();
      }
      if (t < 140) requestAnimationFrame(drawFrame);
      else canvas.remove();
    }
    drawFrame();
  }

  /**********************
   * Advanced: click cells for debug (hidden) *
   **********************/
  // Optional dev aid: click a board cell to teleport current player's token there (uncomment to use)
  // gridEl.addEventListener('click', e => {
  //   const cell = e.target.closest('.cell');
  //   if (!cell) return;
  //   const n = Number(cell.dataset.num);
  //   positions[currentPlayer] = n;
  //   updateStats();
  // });

  // Ensure tokens placed after image load
  const boardImg = document.getElementById('boardImg');
  if (boardImg.complete) updateStats();
  else boardImg.addEventListener('load', updateStats);
</script>
</body>
</html>
